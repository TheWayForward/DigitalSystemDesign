module debounce(
	clk,
	rst,
	key,
	key_pulse
);
	
	//we have 1 key to debounce
	parameter N = 1;
	input clk,rst;
	//input key
	input[N - 1:0] key;
	//pulse generated by the key
	output[N - 1:0] key_pulse;
	//prestate of last pulse
	reg[N - 1:0] key_rst_pre;
	//state of the current pulse
	reg[N - 1:0] key_rst;
	//from top to bottom
	wire[N - 1:0] key_edge;
	
	//non-bloking assignment
	always@(posedge clk or negedge rst)
		begin	
			if(!rst) 
			begin	
				//all one assignment
				key_rst <= {N{1'b1}};
				key_rst_pre <= {N{1'b1}};
			end
			else 
			begin
				key_rst <= key;
				//the past
				key_rst_pre <= key_rst;
			end
		end
		
		//when negedge of key arrives, a high level will be generated by key_edge
		assign key_edge = key_rst_pre & (~key_rst);
		//time delaying counter, 12MHz clk for 20ms delay, counter 18 digits at least
		reg[25:0] cnt;
		//generate delay for 20ms, begin counting when key_edge is positive
		always@(posedge clk or negedge rst)
			begin
				if(!rst)
					cnt <= 0;
				else if(key_edge)
					cnt <= 0;
				else
					cnt <= cnt + 1;
			end
		
		//checker of level after delay
		reg[N - 1:0] key_sec_pre;
		reg[N - 1:0] key_sec;
		
		//check the key after delay
		//if low, generate a high level for one clk cycle
		//else, invalid switch
		always@(posedge clk or negedge rst)
			begin
				if(!rst)
					key_sec <= {N{1'b1}};
				else if(cnt == 26'h3ffff)
					key_sec <= key;
			end
		always@(posedge clk or negedge rst)
			begin
				if(!rst)
					key_sec_pre <= {N{1'b1}};
				else	key_sec_pre <= key_sec;
			end
		
		assign key_pulse = key_sec_pre & (~key_sec);
		
endmodule
